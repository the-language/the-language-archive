#lang scribble/manual
@require[@for-label[racket]]

@(require scribble/decode)
@(require racket)
@(define (subsubsubsection . args)
   (match (apply subsubsection args)
     [(part-start depth tag-prefix tags style title)
      (part-start (+ 1 depth) tag-prefix tags style title)]))

@title{語}
@author{zaoqi}

@defmodule[lang #:lang #:packages ("lang")]

@define-syntax-rule[(重名詞法 名 原) @define-syntax-rule[(名 . 參) (原 . 參)]]

@重名詞法[述機 defproc]
@重名詞法[語 racket]
@重名詞法[述 defform]
@重名詞法[述/子 defform/subs]
@重名詞法[述值 defthing]
WIP:有錯誤
@section{物}
@述機[(等？ [甲 (非 :誤？)] [乙 (非 :誤？)]) :陰-陽？]{返回@語[甲]是否等於@語[乙]。}

@述機[(:列/構？ [物 (非 :誤？)]) :陰-陽？]{返回@語[物]是否是@語[(→:列/構 首 尾)]。}
@述機[(→:列/構 [首 :物？] [尾 :列？]) 首尾？]{沒有強制類型限制。}
@述機[(:列/構.首 [物 :列/構？]) :物？]{若@語[物]是@語[(→:列/構 首 尾)]，返回@語[首]。}
@述機[(:列/構.尾 [物 :列/構？]) :物？]{若@語[物]是@語[(→:列/構 首 尾)]，返回@語[尾]。}
@述機[(:列/空？ [物 (非 :誤？)]) :陰-陽？]{返回@語[物]是否是@語[()]。}
@述值[:列/空 列/空？ #:value ()]

@述機[(:名/文？ [物 (非 :誤？)]) :陰-陽？]
@述機[(:名/構？ [物 (非 :誤？)]) :陰-陽？]
@述機[(→:名/構 [名 :名？] [列 :列？]) :陰-陽？]{沒有強制類型限制。}
@述機[(:名/構.名 [物 :名/構？]) 名？]{沒有強制類型限制。}
@述機[(:名/構.列 [物 :名/構？]) :列？]{沒有強制類型限制。}

@述機[(:集/定？ [物 (非 :誤？)]) :陰-陽？]
@述值[空:集/定 :集/定？]
@述機[(:集/定.增 [物 :集/定？] [名 :物？] [甲 :物？]) :集/定？]
@述機[(:集/定.改 [物 :集/定？] [名 :物？] [機 (-> :物？ :物？)]) :集/定？]
@述機[(:集/定.取 [物 :集/定？] [名 :物？]) :物？]
@述機[(:集/定.含？ [物 :集/定？] [名 :物？]) :陰-陽？]
@述機[(:集/定.删 [物 :集/定？] [名 :物？]) 映？]{必須有，才能刪。}
@述機[(:集/定→:列 [物 :集/定？]) (listof (cons/c any/c any/c))]

@述[(#%式 式 甲 ...)]{使用一個@語[引機？]（@語[式]）。可以寫作@語[{式 甲 ...}]。}
@述[(#%頂 名)]{頂層的物。}

@述機[(:機？ [物 (非 :誤？)]) :陰-陽？]
@述機[(→:機 [形 :物？] [物 :物？]) :機？]{沒有強制類型限制。}
@述機[(:機.用 [物 :機？] [形 :物？]) :物？]{
 用@語[形]應用@語[物]。
 @語[(算 (:機.物 物) -境)]。
 @語[-境]只包含用@語[(:機.形 物)]和@語[形]得到的。

 如果@語[形]和@語[物]不能匹配，這個@語[誤？]是@語[形]產生的。
}
@述機[(:機.形 [物 :機？]) :物？]{
 類似Scheme。如果有不是@語[名？]的，也加入到@語[集/定]。後面的可以覆蓋前面的。
}
@述機[(:機.物 [物 :機？]) 未算？]

@述值[→:列 :機？ #:value (→:機 '(:列) ':列)]
@述值[:名？ :機？ #:value (→:機 '(:物) '((#%頂 :陰陽.若) ((#%頂 :名/構？) :物) #t ((#%頂 :名/文？) :物)))]

@述值[陰 :陰-陽？]
@述值[陽 :陰-陽？]
@述機[(:陰陽.若 [物 陰-陽？] [甲 :物？] [乙 :物？]) :物？]{若@語[陰陽]是@語[陽]，則返回@語[乙]，否則返回@語[丙]。}

@述機[(:式？ [物 (非 :誤？)]) :陰-陽？]
@述機[(→:式 [機 (-> :集/定？ :物？ ... :物？)]) :式？]{
 沒有強制類型限制。
 first-class的宏和特殊形式。
}
@述機[(→:式-1 [物 :式？]) (-> :集/定？ :物？ ... :物？)]{沒有強制類型限制。}

@述值[引 引機？ #:value (→:式 (→:機 '(:集/定 :物) ':物))]

@述機[(:誤？ [物 :物？]) :陰-陽？]
@述機[(→:誤 [物 :物？]) :誤？]
@述機[(→:誤-1 [物 :誤？]) :物？]

@述機[(算 [物 :物？] [集/定 :集/定？]) :物？]

@述值[頂:集/定 :集/定？]

@述[{定 ([名 之物] ...) 物}]{@racket[letrec]。@語[([名 之物] ...)]的名稱是}

@述機[(:構？ [物 (非 :誤？)]) :陰-陽？]
@述機[(->:構 [名 名？] [列 :列？]) :構？]{沒有強制類型限制。}
@述機[(:構.名 [物 構？]) :物？]
@述機[(:構.列 [物 構？]) :物？]

@述機[(取 [名 名？]) 物]{獲取一個包}

@述機[(或 [甲 :物？] [乙 :物？]) :物？]{一般是@語[甲]，可以是@語[乙]。}

@section{頂層的物}
@subsection{機}
看起來是@語[(機 '<形> '((#%頂 <名>) . <形>))]。
@subsection{式}
看起來是@語[(式 (機 '(集/定 . <形>) '((#%頂 算) ((#%頂 列) '#%式 (#%頂 <名>) . <形>) 集/定)))]。

@section{誤}
@subsection{停機}
替換：在進行0或更多次替換後，可以把會停止的任意個@語[物？]替換爲@語[(→:誤 (構 {引 誤/界/停} <未定義>))]，@語[<未定義>]是任意的一個@語[物？]。

實現應該識別出儘量多的停止。

實現應該儘量避免替換。
@subsection{內置}
@racket["沒有強制類型限制。"]在一些構建數據的@語[機？]中出現，表示特定的某些參數或返回值的類型可以是任何@語[物？]。

@語[(非 :誤？)]表示不能是一個@語[誤？]，否則返回值是一個@語[誤？]。
@subsubsection{機}
內置的任何@語[機？]產生的@語[誤？]是@語[(誤 (構 {引 誤/界/機} (列 -名 -式 -位)))]，
@語[-名]是它的名稱，@語[-式]是它的參數，@語[-位]是產生一個@語[誤？]的參數的名稱。
@subsubsection{式}
內置的任何@語[式？]產生的@語[誤？]是@語[(誤 (構 {引 誤/界/式} (列 -名 -集/定 -式 -位)))]，
@語[-名]是它的名稱（一個@語[名？]），@語[-集/定]是環境，@語[-式]是它的參數，@語[-位]是參數的名稱。
@subsubsection{未定義}
@語[算]和@語[#%頂]未定義時產生的@語[:誤？]是@語[(→:誤 (構 {引 誤/界/名} (列 -名 -集/定)))]，@語[-名]是那個@語[名？]，@語[-集/定]是環境。

@section{類Racket語法}
每個vector和symbol會被轉換爲一個@語[:名？]。

@(racketblock {define L->V
 {match-lambda
  [(列 #\！ cs ..1) `#(一 式 ,(L->V cs))]
  [(列 #\# #\% cs ..1) `#(式 ,(L->V cs))]
  [(列 cs ..1 #\- #\1)
   {match (L->V cs)
      [`#(一 ,t) `#(一 ,t 反)]
      [`#(一 ,t ,n) `#(一 ,t (反 ,n))]
      [(? symbol? s) `#(反 ,s)]}]
  [(列 #\→ (and (not #\→) cs) ..1) `#(一 #(#(子 化 至) ,(L->V cs)))]
  [(列 (and (not #\→) cs1) ..1 #\→ (and (not #\→) cs2) ..1) `#(一 #(化 ,(L->V cs1) ,(L->V cs2)))]
  [(列 cs ..1 #\？) `#(一 #(子 化 乎) ,(L->V cs))]
  [(列 (and (not #\.) t) ..1 #\. (and (not #\.) n) ..1) `#(一 #(#(子 化 對) ,(L->V t)) ,(L->V n))]
  [(列 #\: t ..1) `#(一 ,(L->V t))]
  [(列 x ..1 #\: t ..1) `#(一 ,(L->V t) ,(L->V x))]
  [(列 a ..1 (or #\/ #\\) (and (not (or #\/ #\\)) b) ..1) `#(子 ,(L->V a) ,(L->V b))]
  [(列 (and (not #\-) h) ..1 #\- t ..1)
   {match (L->V t)
     [`#(列 ,@xs) `#(列 ,(L->V h) ,@xs)]
     [s `#(列 ,(L->V h) ,s)]}]
  [(and xs (not (列 _ ... (or #\？ #\！ #\# #\% #\- #\1 #\→ #\. (or #\/ #\\) #\:) _ ...)))
   (string->symbol (list->string xs))]}})

